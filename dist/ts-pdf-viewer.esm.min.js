import{GlobalWorkerOptions as n,getDocument as e}from"pdfjs-dist";var t=function(n,e,t,i){return new(t||(t=Promise))((function(s,o){function a(n){try{d(i.next(n))}catch(n){o(n)}}function r(n){try{d(i.throw(n))}catch(n){o(n)}}function d(n){var e;n.done?s(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(a,r)}d((i=i.apply(n,e||[])).next())}))};class i{constructor(e,i){this._visibleAdjPages=2,this.styles="\n<style>\n  #viewer-container {\n    box-sizing: border-box;\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    justify-content: stretch;\n    align-items: stretch;\n    width: 100%;\n    height: 100%;\n    overflow-x: none;\n    overflow-y: none;\n    background: gray;\n  }\n\n  #panel-top {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    flex-shrink: 0;\n    width: 100%;\n    height: 40px;\n    background: dimgray;\n    box-shadow: 0 0 10px rgba(0,0,0,0.75);\n    z-index: 1;\n    transition: height 0.25s ease-out 0.1s;\n  }\n  .hide-panels #panel-top {\n    height: 0;\n    transition: height 0.25s ease-in 0.1s;\n  }\n\n  #panel-bottom {\n    position: absolute;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    flex-grow: 0;\n    flex-shrink: 0;\n    left: calc(50% - 160px);\n    bottom: 10px;\n    width: 320px;\n    height: 40px;  \n    background: dimgray;\n    box-shadow: 0 0 10px rgba(0,0,0,0.75);\n    z-index: 1;\n    transition: height 0.25s ease-out, bottom 0.1s linear 0.25s;\n  }\n  .hide-panels #panel-bottom {\n    bottom: 0;\n    height: 0;\n    transition: bottom 0.1s linear, height 0.25s ease-in 0.1s;\n  }\n\n  #paginator {  \n    user-select: none;\n    font-family: sans-serif;\n    font-size: 16px;\n    color: white;\n  }\n  #paginator-input {\n    text-align: center; \n    width: 30px;\n    height: 20px;\n    margin: 0;\n    padding: 0;\n    outline: none;\n    border: none;\n    color: white;\n    background-color: #303030;\n  }\n\n  #pages-container {\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: center;\n    width: 100%;\n    height: 100%;\n    padding-top: 0px;\n    overflow-x: auto;\n    overflow-y: auto;\n    transition: padding-top 0.25s ease-out 0.1s;\n  }\n  .hide-panels #page-container {\n    padding-top: 40px;\n    transition: padding-top 0.25s ease-in 0.1s;\n  }\n\n  .page-canvas {\n    margin: 10px;\n    box-shadow: 0 0 10px rgba(0,0,0,0.75);\n  }\n  \n</style>\n  ",this.html='\n<div id="viewer-container">\n  <div id="panel-top"></div>\n  <div id="pages-container"></div>\n  <div id="panel-bottom">\n    <div id="paginator">\n      <input id="paginator-input" type="text">\n      <span>/</span>\n      <span id="paginator-total">5</span>\n    </div>\n  </div>\n</div>\n  ',this._pageCanvases=[],this._scale=1,this.onPdfLoadingProgress=n=>{console.log(`${n.loaded}/${n.total}`)},this.onPdfLoadedAsync=n=>t(this,void 0,void 0,(function*(){this._pdfDocument=n,yield this.refreshPageCanvasesAsync(),yield this.renderVisiblePagesAsync()})),this.onPdfClosedAsync=()=>t(this,void 0,void 0,(function*(){this._pdfDocument&&(this._pdfDocument=null),yield this.refreshPageCanvasesAsync()})),this.onPagesContainerScroll=()=>{this.renderVisiblePagesAsync()},this.onPaginatorInput=n=>{n.target instanceof HTMLInputElement&&(n.target.value=n.target.value.replace(/[^\d]+/g,""))},this.onPaginatorChange=n=>{if(n.target instanceof HTMLInputElement){const e=Math.max(Math.min(+n.target.value,this._pdfDocument.numPages),1);e+""!==n.target.value&&(n.target.value=e+""),this.scrollToPage(e-1)}};const s=document.querySelector(e);if(!s)throw new Error("Container not found");if(!(s instanceof HTMLDivElement))throw new Error("Container is not a DIV element");if(this._container=s,!i)throw new Error("Worker source path not defined");n.workerSrc=i,this.initViewerGUI()}destroy(){}openPdfAsync(n){return t(this,void 0,void 0,(function*(){if(this._pdfLoadingTask)return yield this.closePdfAsync(),this.openPdfAsync(n);const t=e(n);this._pdfLoadingTask=t,t.onProgress=this.onPdfLoadingProgress;const i=yield t.promise;this._pdfLoadingTask=null,yield this.onPdfLoadedAsync(i)}))}closePdfAsync(){return t(this,void 0,void 0,(function*(){this._pdfLoadingTask&&(this._pdfLoadingTask.destroyed||(yield this._pdfLoadingTask.destroy()),this._pdfLoadingTask=null),yield this.onPdfClosedAsync()}))}initViewerGUI(){this._shadowRoot=this._container.attachShadow({mode:"open"}),this._shadowRoot.innerHTML=this.styles+this.html;const n=this._shadowRoot.getElementById("paginator-input");n.addEventListener("input",this.onPaginatorInput),n.addEventListener("change",this.onPaginatorChange),this._pagesContainer=this._shadowRoot.querySelector("div#pages-container")}refreshPageCanvasesAsync(){return t(this,void 0,void 0,(function*(){this._pageCanvases.forEach((n=>{n.canvas.remove()})),this._pageCanvases.length=0;const n=this._pdfDocument.numPages;this._shadowRoot.getElementById("paginator-total").innerHTML=n+"",n||this._pagesContainer.removeEventListener("scroll",this.onPagesContainerScroll);for(let e=0;e<n;e++){const n=document.createElement("canvas");n.classList.add("page-canvas");const t=yield this._pdfDocument.getPage(e+1),{width:i,height:s}=t.getViewport({scale:1});this._pagesContainer.append(n),this._pageCanvases.push({canvas:n,ctx:n.getContext("2d"),rendered:!1,renderTask:null,size:{width:i,height:s}})}this.refreshPageCanvasesSize(),this._pagesContainer.addEventListener("scroll",this.onPagesContainerScroll)}))}refreshPageCanvasesSize(){this._pageCanvases.forEach((n=>{const{canvas:e,size:t}=n;e.width=t.width*this._scale,e.height=t.height*this._scale}))}renderVisiblePagesAsync(){return t(this,void 0,void 0,(function*(){const n=this._pdfDocument,e=this._pageCanvases,t=this._scale,i=this.getVisiblePages(this._container,e),s=this.getCurrentPage(this._container,e,i);this._shadowRoot.getElementById("paginator-input").value=s+1+"";const o=Math.max(Math.min(...i)-this._visibleAdjPages,0),a=Math.min(Math.max(...i)+this._visibleAdjPages,e.length-1);for(let i=0;i<e.length;i++)i>=o&&i<=a?e[i].rendered||(yield this.renderPageAsync(n,e,i,t)):e[i].rendered&&this.clearRenderedPage(e,i)}))}scrollToPage(n){const{top:e}=this._pagesContainer.getBoundingClientRect(),{top:t}=this._pageCanvases[n].canvas.getBoundingClientRect(),i=t-(e-this._pagesContainer.scrollTop);this._pagesContainer.scrollTo(0,i)}getVisiblePages(n,e){const t=n.getBoundingClientRect(),i=t.top,s=t.top+t.height,o=new Set;return e.forEach(((n,e)=>{const t=n.canvas.getBoundingClientRect(),a=t.top,r=t.top+t.height;a<s&&r>i&&o.add(e)})),o}getCurrentPage(n,e,t){const i=[...t];if(!i.length)return 0;if(1===i.length)return i[0];const s=n.getBoundingClientRect(),o=s.top,a=s.top+s.height/2;for(const n of i){const t=e[n].canvas.getBoundingClientRect().top;if(t>o)return t>a?n-1:n}throw new Error("Incorrect argument")}renderPageAsync(n,e,i,s){return t(this,void 0,void 0,(function*(){const t=e[i];if(t.renderTask)return;const o=yield n.getPage(i+1),a=o.getViewport({scale:s});if(!t.renderTask){const n={canvasContext:t.ctx,viewport:a},e=o.render(n);t.renderTask=e,yield e.promise,t.renderTask=null,t.rendered=!0}}))}clearRenderedPage(n,e){const t=n[e];t.ctx.clearRect(0,0,t.canvas.width,t.canvas.height),t.rendered=!1}}export{i as TsPdfViewer};
